# Profile data generated by Devel::NYTProf::Reader
# Version: v6.14
# More information at http://metacpan.org/release/Devel-NYTProf/
# Format: time,calls,time/call,code
0.000000,0,0.000000,package Params::Filter;
0.000025,2,0.000012,use v5.36;
0.000001,1,0.000001,our $VERSION = '0.006_002';
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 NAME
0.000000,0,0.000000,
0.000000,0,0.000000,Params::Filter - Fast field filtering for parameter construction
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SYNOPSIS
0.000000,0,0.000000,
0.000000,0,0.000000,use Params::Filter;
0.000000,0,0.000000,
0.000000,0,0.000000,# Define filter rules
0.000000,0,0.000000,my @required_fields = qw(name email);
0.000000,0,0.000000,my @accepted_fields = qw(phone city state zip);
0.000000,0,0.000000,my @excluded_fields = qw(ssn password);
0.000000,0,0.000000,
0.000000,0,0.000000,# Functional interface
0.000000,0,0.000000,# Apply filter to incoming data (from web form, CLI, API, etc.)
0.000000,0,0.000000,my ($filtered_data, $status) = filter(
0.000000,0,0.000000,$incoming_params,    # Data from external source
0.000000,0,0.000000,\@required_fields,
0.000000,0,0.000000,\@accepted_fields,
0.000000,0,0.000000,\@excluded_fields,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($filtered_data) {
0.000000,0,0.000000,# Success - use filtered data
0.000000,0,0.000000,process_user($filtered_data);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Error - missing required fields
0.000000,0,0.000000,die "Validation failed: $status";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Object-oriented interface
0.000000,0,0.000000,my $user_filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['username', 'email'],
0.000000,0,0.000000,accepted => ['first_name', 'last_name', 'phone', 'bio'],
0.000000,0,0.000000,excluded => ['password', 'ssn', 'credit_card'],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply same filter to multiple incoming datasets
0.000000,0,0.000000,my ($user1, $msg1) = $user_filter->apply($web_form_data);
0.000000,0,0.000000,my ($user2, $msg2) = $user_filter->apply($api_request_data);
0.000000,0,0.000000,my ($user3, $msg3) = $user_filter->apply($db_record_data);
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DESCRIPTION
0.000000,0,0.000000,
0.000000,0,0.000000,C<Params::Filter> provides fast, lightweight parameter filtering that
0.000000,0,0.000000,checks only for the presence or absence of specified fields. It does B<not>
0.000000,0,0.000000,validate values - no type checking, truthiness testing, or lookups.
0.000000,0,0.000000,
0.000000,0,0.000000,This module separates field filtering from value validation:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Field filtering** (this module) - Check which fields are present/absent
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Value validation** (later step) - Check if field values are correct
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,This approach handles common parameter issues:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Subroutine signatures can become unwieldy with many parameters
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Ad-hoc argument checking is error-prone
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Validation may not catch missing inputs quickly enough
0.000000,0,0.000000,
0.000000,0,0.000000,=item * The number of fields to check multiplies validation time
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 When to Use This Module
0.000000,0,0.000000,
0.000000,0,0.000000,This module is useful when you have:
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Pre-defined filter rules (from config files, constants, database schemas)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Known downstream input or process parameters (for APIs, method/subroutine arguments, database operations)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Incoming data from differing sources (web forms, APIs, databases, user input)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * No guarantee that incoming data is consistent or complete
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Need to process multiple datasets with the same rules
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Want to reject unwanted fields before value validation
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 When NOT to Use This Module
0.000000,0,0.000000,
0.000000,0,0.000000,If you're constructing both the filter rules B<and> the data structure at the
0.000000,0,0.000000,same point in your code, you probably don't need this module except 
0.000000,0,0.000000,during development or debugging. The module's expected use is 
0.000000,0,0.000000,to apply pre-defined rules to data that may be inconsistent or 
0.000000,0,0.000000,incomplete for its intended use. If there isn't repetition 
0.000000,0,0.000000,or an unreliable data structure, this might be overkill.
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 This Module Does NOT Do Fancy Stuff
0.000000,0,0.000000,
0.000000,0,0.000000,As much as this module attempts to be versatile in usage, there are some 
0.000000,0,0.000000,B<very handy affordances it does NOT provide:>
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * No regex field name matching for designating fields to require, accept, or exclude
0.000000,0,0.000000,
0.000000,0,0.000000,=item * No conditional field designations within a filter:
0.000000,0,0.000000,C<if 'mailing_address' require 'postal_code'>.
0.000000,0,0.000000,But see C<set_required()>, C<set_accepted()>, C<set_excluded()>, 
0.000000,0,0.000000,as ways to adjust a filter's behavior - or just have alternative filters.
0.000000,0,0.000000,
0.000000,0,0.000000,=item * No coderefs or callbacks for use when filtering
0.000000,0,0.000000,
0.000000,0,0.000000,=item * No substitutions or changes to field names
0.000000,0,0.000000,
0.000000,0,0.000000,=item * No built-in filter lists except null [] = none
0.000000,0,0.000000,
0.000000,0,0.000000,=item * No fields B<added> to data, EXCEPT:
0.000000,0,0.000000,
0.000000,0,0.000000,=over8
0.000000,0,0.000000,
0.000000,0,0.000000,* If the provided data resolves to a list or array with an odd number of elements, 
0.000000,0,0.000000,the LAST element is treated as a flag, set to the value 1
0.000000,0,0.000000,
0.000000,0,0.000000,* If the provided data resolves to a single non-reference scalar (probably a text string) 
0.000000,0,0.000000,the data is stored as a hashref value with the key ‘_’, and returned if '_' is
0.000000,0,0.000000,included in the `accepted` list or the list is set to `['*']` (accept all)
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000441,2,0.000220,use Exporter;
0.000003,1,0.000003,our @ISA		= qw{ Exporter  };
0.000000,1,0.000000,our @EXPORT		= qw{ filter };
0.000000,0,0.000000,
0.000000,0,0.000000,sub new_filter {
0.000000,1,0.000000,my ($class,$args) = @_;
0.000007,1,0.000007,$args = {} unless ($args and ref($args) =~ /hash/i);
0.000000,0,0.000000,my $self			= {
0.000000,0,0.000000,required	=> $args->{required} || [],
0.000000,0,0.000000,accepted	=> $args->{accepted} || [],
0.000000,0,0.000000,excluded	=> $args->{excluded} || [],
0.000001,1,0.000001,debug		=> $args->{DEBUG} || $args->{debug} || 0,
0.000000,0,0.000000,};
0.000000,1,0.000000,bless $self, __PACKAGE__;
0.000001,1,0.000001,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 OBJECT-ORIENTED INTERFACE
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 new_filter
0.000000,0,0.000000,
0.000000,0,0.000000,my $filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['field1', 'field2'],
0.000000,0,0.000000,accepted => ['field3', 'field4', 'field5'],
0.000000,0,0.000000,excluded => ['forbidden_field'],
0.000000,0,0.000000,DEBUG    => 1,              # Optional debug mode
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Empty constructor - rejects all fields by default
0.000000,0,0.000000,my $strict_filter = Params::Filter->new_filter();
0.000000,0,0.000000,
0.000000,0,0.000000,Creates a reusable filter object with predefined field rules. The filter
0.000000,0,0.000000,can then be applied to multiple datasets using the L</apply> method.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Parameters
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<required> - Arrayref of names of required fields (default: [])
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<accepted> - Arrayref of names of optional fields (default: [])
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<excluded> - Arrayref of names of fields to always remove (default: [])
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<DEBUG> - Boolean to enable debug warnings (default: 0)
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Returns
0.000000,0,0.000000,
0.000000,0,0.000000,A C<Params::Filter> object
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Example
0.000000,0,0.000000,
0.000000,0,0.000000,# Create filter for user registration data
0.000000,0,0.000000,my $user_filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['username', 'email'],
0.000000,0,0.000000,accepted => ['first_name', 'last_name', 'phone', 'bio'],
0.000000,0,0.000000,excluded => ['password', 'ssn', 'credit_card'],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply to multiple incoming datasets
0.000000,0,0.000000,my ($user1, $msg1) = $user_filter->apply($web_form_data);
0.000000,0,0.000000,my ($user2, $msg2) = $user_filter->apply($api_request_data);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 apply
0.000000,0,0.000000,
0.000000,0,0.000000,my ($filtered, $status) = $filter->apply($input_data);
0.000000,0,0.000000,
0.000000,0,0.000000,Applies the filter's predefined rules to input data. This is the OO
0.000000,0,0.000000,equivalent of the L</filter> function.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Parameters
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<$input_data> - Hashref, arrayref, or scalar to filter
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Returns
0.000000,0,0.000000,
0.000000,0,0.000000,In list context: C<(hashref, status_message)> or C<(undef, error_message)>
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context: Hashref with filtered parameters, or C<undef> on failure
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Example
0.000000,0,0.000000,
0.000000,0,0.000000,my $filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['id', 'type'],
0.000000,0,0.000000,accepted => ['name', 'value'],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Process multiple records from database
0.000000,0,0.000000,for my $record (@db_records) {
0.000000,0,0.000000,my ($filtered, $msg) = $filter->apply($record);
0.000000,0,0.000000,if ($filtered) {
0.000000,0,0.000000,process_record($filtered);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,log_error("Record failed: $msg");
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_required {
0.000000,0,0.000000,my ($self, @fields)	= @_;
0.000000,0,0.000000,@fields 			= ref $fields[0] eq 'ARRAY' ? $fields[0]->@* : @fields;
0.000000,0,0.000000,my @required		= grep { defined } @fields;
0.000000,0,0.000000,$self->{required}	= @required ? [ @required ] : [];
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_accepted {
0.000000,0,0.000000,my ($self, @fields)	= @_;
0.000000,0,0.000000,@fields 			= ref $fields[0] eq 'ARRAY' ? $fields[0]->@* : @fields;
0.000000,0,0.000000,my @accepted		= grep { defined } @fields;
0.000000,0,0.000000,$self->{accepted}	= @accepted ? [ @accepted ] : [];
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_all {
0.000000,0,0.000000,my ($self)			= @_;
0.000000,0,0.000000,$self->{accepted}	= ['*'];
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub accept_none {
0.000000,0,0.000000,my ($self)			= @_;
0.000000,0,0.000000,$self->{accepted}	= [];
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub set_excluded {
0.000000,0,0.000000,my ($self, @fields)	= @_;
0.000000,0,0.000000,@fields				= ref $fields[0] eq 'ARRAY' ? $fields[0]->@* : @fields;
0.000000,0,0.000000,my @excluded		= grep { defined } @fields;
0.000000,0,0.000000,$self->{excluded}	= @excluded ? [ @excluded ] : [];
0.000000,0,0.000000,return $self;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,sub apply {
0.000229,10000,0.000000,my ($self,$args) = @_;
0.000376,10000,0.000000,my $req		= $self->{required} || [];
0.000415,10000,0.000000,my $ok		= $self->{accepted} || [];
0.000326,10000,0.000000,my $no		= $self->{excluded} || [];
0.000428,10000,0.000000,my $db		= $self->{debug} || 0;
0.001617,10000,0.000000,my @result	= filter( $args, $req, $ok, $no, $db);
0.003688,10000,0.000000,return wantarray ? @result : $result[0];
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 MODIFIER METHODS
0.000000,0,0.000000,
0.000000,0,0.000000,Modifier methods allow dynamic configuration of filter rules after creation of the filter object.
0.000000,0,0.000000,All methods return C<$self> for method chaining. 
0.000000,0,0.000000,A filter may call its modifier methods more than once, and the changes take effect immediately.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 set_required
0.000000,0,0.000000,
0.000000,0,0.000000,$filter->set_required(['id', 'name', 'email']);  # Arrayref
0.000000,0,0.000000,$filter->set_required('id', 'name', 'email');    # List
0.000000,0,0.000000,$filter->set_required();                         # Clears to []
0.000000,0,0.000000,
0.000000,0,0.000000,Sets the required field names. Accepts either an arrayref or a list of
0.000000,0,0.000000,field names. Calling with no arguments sets required to empty array.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 set_accepted
0.000000,0,0.000000,
0.000000,0,0.000000,$filter->set_accepted(['phone', 'city']);  # Arrayref
0.000000,0,0.000000,$filter->set_accepted('phone', 'city');    # List
0.000000,0,0.000000,$filter->set_accepted();                   # Clears to []
0.000000,0,0.000000,$filter->set_accepted(['*']);              # Accept all (except excluded)
0.000000,0,0.000000,
0.000000,0,0.000000,Sets the optional (accepted) field names. Accepts either an arrayref or a
0.000000,0,0.000000,list of field names. Calling with no arguments sets accepted to empty array.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 set_excluded
0.000000,0,0.000000,
0.000000,0,0.000000,$filter->set_excluded(['password', 'ssn']);  # Arrayref
0.000000,0,0.000000,$filter->set_excluded('password', 'ssn');    # List
0.000000,0,0.000000,$filter->set_excluded();                     # Clears to []
0.000000,0,0.000000,
0.000000,0,0.000000,Sets the excluded field names (fields to always remove). Accepts either an
0.000000,0,0.000000,arrayref or a list of field names. Calling with no arguments sets excluded
0.000000,0,0.000000,to empty array.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 accept_all
0.000000,0,0.000000,
0.000000,0,0.000000,$filter->accept_all();  # Sets accepted to ['*']
0.000000,0,0.000000,
0.000000,0,0.000000,Convenience method that sets accepted fields to C<['*']> (wildcard mode),
0.000000,0,0.000000,allowing all fields except those in excluded.
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 accept_none
0.000000,0,0.000000,
0.000000,0,0.000000,$filter->accept_none();  # Sets accepted to []
0.000000,0,0.000000,
0.000000,0,0.000000,Convenience method that sets accepted fields to C<[]> (empty array),
0.000000,0,0.000000,allowing only required fields.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Modifier Method Examples
0.000000,0,0.000000,
0.000000,0,0.000000,# Method chaining for one-liner configuration
0.000000,0,0.000000,my $filter = Params::Filter->new_filter();
0.000000,0,0.000000,# When needed:
0.000000,0,0.000000,$filter->set_required(['id', 'name'])
0.000000,0,0.000000,->set_accepted(['email', 'phone'])
0.000000,0,0.000000,->set_excluded(['password']);
0.000000,0,0.000000,
0.000000,0,0.000000,# Environment-based configuration
0.000000,0,0.000000,my $filter = Params::Filter->new_filter();
0.000000,0,0.000000,
0.000000,0,0.000000,if ($ENV{MODE} eq 'production') {
0.000000,0,0.000000,$filter->set_required(['api_key'])
0.000000,0,0.000000,->set_accepted(['timeout', 'retries'])
0.000000,0,0.000000,->set_excluded(['debug_info']);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,$filter->set_required(['debug_mode'])
0.000000,0,0.000000,->accept_all();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Dynamic configuration from config file
0.000000,0,0.000000,if ( $DEBUG ) {
0.000000,0,0.000000,my $db_config = load_config('debug_fields.json');
0.000000,0,0.000000,$filter->set_required($db_config->{required})
0.000000,0,0.000000,->set_accepted($db_config->{accepted})
0.000000,0,0.000000,->set_excluded($db_config->{excluded});
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FUNCTIONAL INTERFACE
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 filter
0.000000,0,0.000000,
0.000000,0,0.000000,my ($filtered, $status) = filter(
0.000000,0,0.000000,$input_data,     # Hashref, arrayref, or scalar
0.000000,0,0.000000,\@required,      # Arrayref of required field names
0.000000,0,0.000000,\@accepted,      # Arrayref of optional field names (default: [])
0.000000,0,0.000000,\@excluded,      # Arrayref of names of fields to remove (default: [])
0.000000,0,0.000000,$debug_mode,     # Boolean: enable warnings (default: 0)
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Scalar context - returns filtered hashref or undef on failure
0.000000,0,0.000000,my $result = filter($input, \@required, \@accepted);
0.000000,0,0.000000,
0.000000,0,0.000000,Filters input data according to field specifications. Only checks for
0.000000,0,0.000000,presence/absence of fields, not field values.
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Parameters
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<$input_data> - Input parameters (hashref, arrayref, or scalar)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<\@required> - Arrayref of names of fields that B<must> be present
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<\@accepted> - Arrayref of optional names of fields to accept (default: [])
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<\@excluded> - Arrayref of names of fields to remove even if accepted (default: [])
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<$debug_mode> - Boolean to enable warnings (default: 0)
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Returns
0.000000,0,0.000000,
0.000000,0,0.000000,In list context: C<(hashref, status_message)> or C<(undef, error_message)>
0.000000,0,0.000000,
0.000000,0,0.000000,In scalar context: Hashref with filtered parameters, or C<undef> on failure
0.000000,0,0.000000,
0.000000,0,0.000000,=head3 Example
0.000000,0,0.000000,
0.000000,0,0.000000,# Define filter rules (could be from config file)
0.000000,0,0.000000,my @required = qw(username email);
0.000000,0,0.000000,my @accepted = qw(full_name phone);
0.000000,0,0.000000,my @excluded = qw(password ssn);
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply to incoming data from web form
0.000000,0,0.000000,my ($user_data, $msg) = filter(
0.000000,0,0.000000,$form_submission,
0.000000,0,0.000000,\@required,
0.000000,0,0.000000,\@accepted,
0.000000,0,0.000000,\@excluded,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($user_data) {
0.000000,0,0.000000,create_user($user_data);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,log_error($msg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.005244,240000,0.000000,sub filter ($args,$req,$ok=[],$no=[],$db=0) {
0.001276,40000,0.000000,my %args		= ();
0.000938,40000,0.000000,my @messages	= ();	# Parsing messages (always reported)
0.000738,40000,0.000000,my @warnings	= ();	# Debug warnings (only when $db is true)
0.000000,0,0.000000,
0.019081,40000,0.000000,if (ref $args eq 'HASH') {
0.000000,0,0.000000,%args	= $args->%*
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif (ref $args eq 'ARRAY') {
0.000000,0,0.000000,if (ref($args->[0]) eq 'HASH') {
0.000000,0,0.000000,%args	= $args->[0]->%*;			# Ignore the rest
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,my @args	= $args->@*;
0.000000,0,0.000000,if (@args == 1) {
0.000000,0,0.000000,%args = ( '_' => $args[0] );	# make it a value with key '_'
0.000000,0,0.000000,my $preview = length($args[0]) > 20
0.000000,0,0.000000,? substr($args[0], 0, 20) . '...'
0.000000,0,0.000000,: $args[0];
0.000000,0,0.000000,push @messages => "Plain text argument accepted with key '_': '$preview'";
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( @args % 2 ) {
0.000000,0,0.000000,%args = (@args, 1);				# make last arg element a flag
0.000000,0,0.000000,push @messages => "Odd number of arguments provided; " .
0.000000,0,0.000000,"last element '$args[-1]' converted to flag with value 1";
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,%args = @args;					# turn array into hash pairs
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,elsif ( !ref $args ) {
0.000000,0,0.000000,%args	= ( '_' => $args);				# make it a value with key '_'
0.000000,0,0.000000,my $preview = length($args) > 20
0.000000,0,0.000000,? substr($args, 0, 20) . '...'
0.000000,0,0.000000,: $args;
0.000000,0,0.000000,push @messages => "Plain text argument accepted with key '_': '$preview'";
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.002991,40000,0.000000,my @required_flds	= $req->@*;
0.000999,40000,0.000000,unless ( keys %args ) {
0.000000,0,0.000000,my $err = "Unable to initialize without required arguments: " .
0.000000,0,0.000000,join ', ' => map { "'$_'" } @required_flds;
0.000000,0,0.000000,return wantarray ? (undef, $err) : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001654,40000,0.000000,if ( scalar keys(%args) < @required_flds ) {
0.000000,0,0.000000,my $err	= "Unable to initialize without all required arguments: " .
0.000000,0,0.000000,join ', ' => map { "'$_'" } @required_flds;
0.000000,0,0.000000,return wantarray ? (undef, $err) : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now create the output hashref
0.000734,40000,0.000000,my $filtered	= {};
0.000000,0,0.000000,
0.000000,0,0.000000,# Check for each required field
0.000707,40000,0.000000,my @missing_required;
0.000809,40000,0.000000,my $used_keys	= 0;
0.002791,40000,0.000000,for my $fld (@required_flds) {
0.011910,110000,0.000000,if ( exists $args{$fld} ) {
0.009025,110000,0.000000,$filtered->{$fld} = delete $args{$fld};
0.002264,110000,0.000000,$used_keys++;
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,push @missing_required => $fld;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,# Return fast if all set
0.000000,0,0.000000,# required fields assured and no other fields provided
0.005241,40000,0.000000,if ( keys(%args) == 0 ) {
0.000000,0,0.000000,return wantarray ? ($filtered, "Admitted") : $filtered;
0.000000,0,0.000000,}
0.000000,0,0.000000,# required fields assured and no more fields allowed
0.002069,30000,0.000000,if ( scalar keys $filtered->%* == @required_flds and not $ok->@*) {
0.000000,0,0.000000,return wantarray ? ($filtered, "Admitted") : $filtered;
0.000000,0,0.000000,}
0.000000,0,0.000000,# Can't continue
0.000742,30000,0.000000,if ( @missing_required ) {
0.000000,0,0.000000,my $err = "Unable to initialize without required arguments: " .
0.000000,0,0.000000,join ', ' => map { "'$_'" } @missing_required;
0.000000,0,0.000000,return wantarray ? (undef, $err) : undef;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Now remove any excluded fields
0.000488,30000,0.000000,my @excluded;
0.002116,30000,0.000000,for my $fld ($no->@*) {
0.008270,80000,0.000000,if ( exists $args{$fld} ) {
0.003663,80000,0.000000,delete $args{$fld};
0.002689,80000,0.000000,push @excluded => $fld;
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Check if wildcard '*' appears in accepted list
0.002912,30000,0.000000,my $has_wildcard = grep { $_ eq '*' } $ok->@*;
0.000000,0,0.000000,
0.003074,30000,0.000000,if ($has_wildcard) {
0.000000,0,0.000000,# Wildcard present: accept all remaining fields
0.000000,0,0.000000,for my $fld (keys %args) {
0.004474,40000,0.000000,$filtered->{$fld} = delete $args{$fld};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,else {
0.000000,0,0.000000,# Track but don't include if not on @accepted list
0.001730,20000,0.000000,for my $fld ($ok->@*) {
0.005307,40000,0.000000,if ( exists $args{$fld} ) {
0.000000,0,0.000000,$filtered->{$fld} = delete $args{$fld};
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.001263,30000,0.000000,my @unrecognized	= keys %args;	# Everything left
0.000629,30000,0.000000,if ( $db and @unrecognized > 0 ) {
0.000000,0,0.000000,push @warnings => "Ignoring unrecognized arguments: " .
0.000000,0,0.000000,join ', ' => map { "'$_'" } @unrecognized;
0.000000,0,0.000000,}
0.000501,30000,0.000000,if ( $db and @excluded > 0 ) {
0.000000,0,0.000000,push @warnings => "Ignoring excluded arguments: " .
0.000000,0,0.000000,join ', ' => map { "'$_'" } @excluded;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Combine parsing messages (always) with debug warnings (if debug mode)
0.001085,30000,0.000000,my @all_msgs	= (@messages, @warnings);
0.001040,30000,0.000000,my $return_msg	= @all_msgs
0.000000,0,0.000000,? join "\n" => @all_msgs
0.000000,0,0.000000,: "Admitted";
0.000000,0,0.000000,
0.013842,30000,0.000000,return wantarray ? ( $filtered, $return_msg ) : $filtered;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 RETURN VALUES
0.000000,0,0.000000,
0.000000,0,0.000000,Both L</filter> and L</apply> return different values depending on context:
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Success
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * List context: C<(hashref, "Admitted")> or C<(hashref, warning_message)>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Scalar context: Hashref with filtered parameters
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Failure
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * List context: C<(undef, error_message)>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Scalar context: C<undef>
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Common Status Messages
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * "Admitted" - All required fields present, filtering successful
0.000000,0,0.000000,
0.000000,0,0.000000,=item * "Plain text argument accepted with key '_': '...'" - Parsing message (always shown)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * "Odd number of arguments provided; last element 'X' converted to flag with value 1" - Parsing message (always shown)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * "Ignoring excluded arguments: 'field1', 'field2'..." - Debug message (debug mode only)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * "Ignoring unrecognized arguments: 'field1', 'field2'..." - Debug message (debug mode only)
0.000000,0,0.000000,
0.000000,0,0.000000,=item * "Unable to initialize without required arguments: 'field1', 'field2'..." - Error
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 FEATURES
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Dual interface** - Functional or OO usage
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Fast-fail** - Returns immediately on missing required parameters
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Fast-success** - Returns immediately if all required parameters are provided and no others are provided or will be accepted
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Flexible input** - Accepts hashrefs, arrayrefs, or scalars
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Wildcard support** - Use C<'*'> in accepted list to accept all fields
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **No value checking** - Only presence/absence of fields
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Debug mode** - Optional warnings about unrecognized or excluded fields
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Method chaining** - Modifier methods return C<$self>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **Perl 5.36+** - Modern Perl with signatures and post-deref
0.000000,0,0.000000,
0.000000,0,0.000000,=item * **No dependencies** - Only core Perl's L<Exporter>
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 DEBUG MODE
0.000000,0,0.000000,
0.000000,0,0.000000,Debug mode provides additional information about field filtering during development:
0.000000,0,0.000000,
0.000000,0,0.000000,my ($filtered, $msg) = filter(
0.000000,0,0.000000,$input,
0.000000,0,0.000000,['name'],
0.000000,0,0.000000,['email'],
0.000000,0,0.000000,['password'],
0.000000,0,0.000000,1,  # Enable debug mode
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,Debug warnings (only shown when debug mode is enabled):
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Excluded fields that were removed
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Unrecognized fields that were ignored
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,Parsing messages (always shown, regardless of debug mode):
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Plain text arguments accepted with key '_'
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Odd number of array elements converted to flags
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,Parsing messages inform you about transformations the filter made to your input format.
0.000000,0,0.000000,These are always reported because they affect the structure of the returned data.
0.000000,0,0.000000,Debug warnings help you understand which fields were filtered out during development.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 WILDCARD SUPPORT
0.000000,0,0.000000,
0.000000,0,0.000000,The C<accepted> parameter supports a wildcard C<'*'> to accept all fields
0.000000,0,0.000000,(except those in C<excluded>).
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Wildcard Usage
0.000000,0,0.000000,
0.000000,0,0.000000,# Accept all fields
0.000000,0,0.000000,filter($input, [], ['*']);
0.000000,0,0.000000,
0.000000,0,0.000000,# Accept all except specific exclusions
0.000000,0,0.000000,filter($input, [], ['*'], ['password', 'ssn']);
0.000000,0,0.000000,
0.000000,0,0.000000,# Required + all other fields
0.000000,0,0.000000,filter($input, ['id', 'name'], ['*']);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Important Notes
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * C<'*'> is B<only special in the C<accepted> parameter>
0.000000,0,0.000000,
0.000000,0,0.000000,=item * In C<required> or C<excluded>, C<'*'> is treated as a literal field name
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Empty C<[]> for accepted means "accept none beyond required"
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Multiple wildcards are redundant but harmless
0.000000,0,0.000000,
0.000000,0,0.000000,=item * Exclusions are always removed before acceptance is processed
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Debugging Pattern
0.000000,0,0.000000,
0.000000,0,0.000000,A common debugging pattern is to add C<'*'> to an existing accepted list:
0.000000,0,0.000000,
0.000000,0,0.000000,# Normal operation
0.000000,0,0.000000,filter($input, ['id'], ['name', 'email']);
0.000000,0,0.000000,
0.000000,0,0.000000,# Debugging - see all inputs
0.000000,0,0.000000,filter($input, ['id'], ['name', 'email', '*']);
0.000000,0,0.000000,
0.000000,0,0.000000,Or, start with minimum to troubleshoot specific fields
0.000000,0,0.000000,
0.000000,0,0.000000,filter($input, ['id'], []);
0.000000,0,0.000000,
0.000000,0,0.000000,# then
0.000000,0,0.000000,filter($input, ['id'], ['name']);
0.000000,0,0.000000,
0.000000,0,0.000000,# then
0.000000,0,0.000000,filter($input, ['id'], ['email']);
0.000000,0,0.000000,
0.000000,0,0.000000,# then
0.000000,0,0.000000,filter($input, ['id'], ['name', 'email']);
0.000000,0,0.000000,
0.000000,0,0.000000,# then
0.000000,0,0.000000,filter($input, ['id'], ['*']);
0.000000,0,0.000000,
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 EXAMPLES
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Basic Form Validation
0.000000,0,0.000000,
0.000000,0,0.000000,use Params::Filter;    # auto-imports filter() subroutine
0.000000,0,0.000000,
0.000000,0,0.000000,# Define filtering rules (could be from config file)
0.000000,0,0.000000,my @required = qw(name email);
0.000000,0,0.000000,my @accepted = qw(phone city state zip);
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply to incoming web form data
0.000000,0,0.000000,my ($user_data, $status) = filter(
0.000000,0,0.000000,$form_submission,   # Data from web form
0.000000,0,0.000000,\@required,
0.000000,0,0.000000,\@accepted,
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,if ($user_data) {
0.000000,0,0.000000,register_user($user_data);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,show_error($status);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Reusable Filter for Multiple Data Sources
0.000000,0,0.000000,
0.000000,0,0.000000,# Create filter once
0.000000,0,0.000000,my $user_filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['username', 'email'],
0.000000,0,0.000000,accepted => ['full_name', 'phone', 'bio'],
0.000000,0,0.000000,excluded => ['password', 'ssn', 'credit_card'],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply to multiple incoming datasets
0.000000,0,0.000000,my ($user1, $msg1) = $user_filter->apply($web_form_data);
0.000000,0,0.000000,my ($user2, $msg2) = $user_filter->apply($api_request_data);
0.000000,0,0.000000,my ($user3, $msg3) = $user_filter->apply($csv_import_data);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Environment-Specific Filtering
0.000000,0,0.000000,
0.000000,0,0.000000,my $filter = Params::Filter->new_filter();
0.000000,0,0.000000,
0.000000,0,0.000000,if ($ENV{APP_MODE} eq 'production') {
0.000000,0,0.000000,# Strict: only specific fields allowed
0.000000,0,0.000000,$filter->set_required(['api_key'])
0.000000,0,0.000000,->set_accepted(['timeout', 'retries'])
0.000000,0,0.000000,->set_excluded(['debug_info', 'verbose']);
0.000000,0,0.000000,} else {
0.000000,0,0.000000,# Development: allow everything
0.000000,0,0.000000,$filter->set_required(['debug_mode'])
0.000000,0,0.000000,->accept_all();
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,my ($config, $msg) = $filter->apply($incoming_config);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Security Filtering
0.000000,0,0.000000,
0.000000,0,0.000000,# Remove sensitive fields from user input
0.000000,0,0.000000,my ($safe_data, $msg) = filter(
0.000000,0,0.000000,$user_input,
0.000000,0,0.000000,['username', 'email'],           # required
0.000000,0,0.000000,['full_name', 'phone', 'bio'],    # accepted
0.000000,0,0.000000,['password', 'ssn', 'api_key'],   # excluded
0.000000,0,0.000000,);
0.000000,0,0.000000,
0.000000,0,0.000000,# Result contains only safe fields
0.000000,0,0.000000,# password, ssn, api_key are removed even if provided
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Dynamic Configuration from File
0.000000,0,0.000000,
0.000000,0,0.000000,# Load filter rules from config file
0.000000,0,0.000000,my $config = decode_json(`cat filters.json`);
0.000000,0,0.000000,
0.000000,0,0.000000,my $filter = Params::Filter->new_filter()
0.000000,0,0.000000,->set_required($config->{user_create}{required})
0.000000,0,0.000000,->set_accepted($config->{user_create}{accepted})
0.000000,0,0.000000,->set_excluded($config->{user_create}{excluded});
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply to incoming data
0.000000,0,0.000000,my ($filtered, $msg) = $filter->apply($api_data);
0.000000,0,0.000000,
0.000000,0,0.000000,=head2 Data Segregation for Multiple Subsystems
0.000000,0,0.000000,
0.000000,0,0.000000,A common pattern is splitting incoming data into subsets for different
0.000000,0,0.000000,handlers or storage locations. Each filter extracts only the fields needed
0.000000,0,0.000000,for its specific purpose, implementing security through compartmentalization.
0.000000,0,0.000000,
0.000000,0,0.000000,# Main subscription form collects: 
0.000000,0,0.000000,#  name, email, zip, 
0.000000,0,0.000000,#  user_id, password, credit_card_number, subscription_term
0.000000,0,0.000000,
0.000000,0,0.000000,# Subscriber profile form collects: 
0.000000,0,0.000000,#  name, email, address, city, state, zip, 
0.000000,0,0.000000,#  user_id, password, credit_card_number, 
0.000000,0,0.000000,#  phone, occupation, position, education 
0.000000,0,0.000000,#  alt_card_number, billing_address, billing_zip
0.000000,0,0.000000,
0.000000,0,0.000000,# Promo subscription form collects: 
0.000000,0,0.000000,#  name, email, zip, subscription_term, 
0.000000,0,0.000000,#  user_id, password, credit_card_number, promo_code
0.000000,0,0.000000,
0.000000,0,0.000000,my $data = $webform->input(); # From any of the above
0.000000,0,0.000000,
0.000000,0,0.000000,# Filters
0.000000,0,0.000000,# Personal data - general user info (no sensitive data)
0.000000,0,0.000000,my $person_filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['name', 'user_id', 'email'],
0.000000,0,0.000000,accepted => ['address', 'city', 'state', 'zip', 'phone', 'occupation', 'position', 'education'],
0.000000,0,0.000000,excluded => ['password', 'credit_card_number'],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Business data - subscription and billing info
0.000000,0,0.000000,my $biz_filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['user_id', 'subscription_term', 'credit_card_number', 'zip'],
0.000000,0,0.000000,accepted => ['alt_card_number', 'billing_address', 'billing_zip', 'promo_code'],
0.000000,0,0.000000,excluded => ['password'],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Authentication data - only credentials
0.000000,0,0.000000,my $auth_filter = Params::Filter->new_filter({
0.000000,0,0.000000,required => ['user_id', 'password'],
0.000000,0,0.000000,accepted => [],
0.000000,0,0.000000,excluded => [],
0.000000,0,0.000000,});
0.000000,0,0.000000,
0.000000,0,0.000000,# Apply all filters to the same web form submission
0.000000,0,0.000000,my ($person_data, $pmsg) = $person_filter->apply($data);
0.000000,0,0.000000,my ($biz_data,    $bmsg) = $biz_filter->apply($data);
0.000000,0,0.000000,my ($auth_data,   $amsg) = $auth_filter->apply($data);
0.000000,0,0.000000,
0.000000,0,0.000000,unless ($person_data && $biz_data && $auth_data) {
0.000000,0,0.000000,return "Unable to add user: " .
0.000000,0,0.000000,join ' ' => grep { $_ ne 'Admitted' } ($pmsg, $bmsg, $amsg);
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Collect any debug warnings from successful filters
0.000000,0,0.000000,if ($self->{DEBUG}) {
0.000000,0,0.000000,my @warnings = grep { $_ ne 'Admitted' } ($pmsg, $bmsg, $amsg);
0.000000,0,0.000000,warn "Params filter debug warnings:\n" . join("\n", @warnings) . "\n"
0.000000,0,0.000000,if @warnings;
0.000000,0,0.000000,}
0.000000,0,0.000000,
0.000000,0,0.000000,# Route each subset to appropriate handler
0.000000,0,0.000000,$self->add_user($person_data);           # User profile
0.000000,0,0.000000,$self->set_subscription($biz_data);       # Billing system
0.000000,0,0.000000,$self->set_password($auth_data);          # Auth system
0.000000,0,0.000000,
0.000000,0,0.000000,# continue ...
0.000000,0,0.000000,B<Note>: The original C<$data> is not modified by any filter. Each call to
0.000000,0,0.000000,C<apply()> creates its own internal copy, so the same data can be safely
0.000000,0,0.000000,processed by multiple filters.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 SEE ALSO
0.000000,0,0.000000,
0.000000,0,0.000000,=over 4
0.000000,0,0.000000,
0.000000,0,0.000000,=item * L<Params::Validate> - Full-featured parameter validation
0.000000,0,0.000000,
0.000000,0,0.000000,=item * L<Data::Verifier> - Data structure validation
0.000000,0,0.000000,
0.000000,0,0.000000,=item * L<JSON::Schema::Modern> - JSON Schema validation
0.000000,0,0.000000,
0.000000,0,0.000000,=back
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 AUTHOR
0.000000,0,0.000000,
0.000000,0,0.000000,Bruce Van Allen <bva@cruzio.com>
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 LICENSE
0.000000,0,0.000000,
0.000000,0,0.000000,This module is licensed under the same terms as Perl itself.
0.000000,0,0.000000,See L<perlartistic|https://dev.perl.org/licenses/artistic.html>.
0.000000,0,0.000000,
0.000000,0,0.000000,=head1 COPYRIGHT
0.000000,0,0.000000,
0.000000,0,0.000000,Copyright (C) 2026, Bruce Van Allen
0.000000,0,0.000000,
0.000000,0,0.000000,=cut
0.000000,0,0.000000,
0.000002,1,0.000002,1;
